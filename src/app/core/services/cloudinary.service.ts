import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable, map, switchMap } from 'rxjs';
import { environment } from '../../../environments/environment';

/**
 * Payload forwarded to the backend in order to obtain an authenticated
 * Cloudinary signature. Optional values let the caller tweak the
 * destination folder, the desired public id or the type of resource.
 */
interface CloudinarySignaturePayload {
  folder?: string;
  publicId?: string;
  resourceType?: string;
  [key: string]: unknown;
}

/**
 * Describes the payload returned by the backend signature endpoint. The
 * hash is generated server-side with the Cloudinary secret and reused for
 * the actual upload request.
 */
export interface CloudinarySignatureResponse {
  timestamp: number;
  signature: string;
  cloudName: string;
  apiKey: string;
  uploadPreset?: string;
  publicId?: string;
}

/**
 * Client-side options accepted by the uploader. Exposes the Cloudinary
 * folder, a desired public id and low-level configuration for custom
 * resources (videos, raw files...).
 */
export interface CloudinaryUploadOptions {
  folder?: string;
  publicId?: string;
  resourceType?: 'image' | 'video' | 'raw' | 'auto';
  signaturePayload?: Record<string, unknown>;
}

interface CloudinaryUploadApiResponse {
  public_id: string;
  secure_url: string;
}

/**
 * Normalised result consumed by the front-end widgets once a file is
 * persisted on Cloudinary.
 */
export interface CloudinaryUploadResult {
  publicId: string;
  secureUrl: string;
}

@Injectable({ providedIn: 'root' })
export class CloudinaryService {
  private readonly apiUrl = environment.apiUrl;

  constructor(private readonly http: HttpClient) {}

  /**
   * Requests a signed payload from the backend before hitting the
   * Cloudinary upload endpoint. The secret key never leaves the server so
   * the client retrieves a short-lived signature instead.
   *
   * @param payload optional overrides (folder, public id, resource type)
   *   forwarded to the backend when computing the signature
   * @returns the generated signature alongside Cloudinary account metadata
   */
  getUploadSignature(payload: CloudinarySignaturePayload = {}): Observable<CloudinarySignatureResponse> {
    return this.http.post<CloudinarySignatureResponse>(`${this.apiUrl}/cloudinary/signature`, payload);
  }

  /**
   * Streams the provided file to Cloudinary using the short-lived
   * signature previously generated by the backend.
   *
   * @param file binary content selected by the end user
   * @param options client-side overrides such as destination folder or
   *   explicit resource type (defaults to `image`)
   * @returns an observable emitting the public id and the secure delivery
   *   URL once the upload succeeds
   */
  uploadImage(file: File, options: CloudinaryUploadOptions = {}): Observable<CloudinaryUploadResult> {
    return this.getUploadSignature({
      folder: options.folder,
      publicId: options.publicId,
      resourceType: options.resourceType,
      ...options.signaturePayload,
    }).pipe(
      switchMap((signature) => {
        const formData = new FormData();
        formData.append('file', file);
        formData.append('timestamp', String(signature.timestamp));
        formData.append('signature', signature.signature);
        formData.append('api_key', signature.apiKey);

        if (signature.uploadPreset) {
          formData.append('upload_preset', signature.uploadPreset);
        }

        if (options.folder) {
          formData.append('folder', options.folder);
        }

        const publicId = signature.publicId || options.publicId;
        if (publicId) {
          formData.append('public_id', publicId);
        }

        const resourceType = options.resourceType ?? 'image';
        const uploadUrl = `https://api.cloudinary.com/v1_1/${signature.cloudName}/${resourceType}/upload`;

        return this.http.post<CloudinaryUploadApiResponse>(uploadUrl, formData).pipe(
          map((response) => ({
            publicId: response.public_id,
            secureUrl: response.secure_url,
          }))
        );
      })
    );
  }
}
